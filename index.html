<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í† ë¼ì™€ ê±°ë¶ì´ ìŠ¤í† ë¦¬ ê·¸ë˜í”„ & ì±—ë´‡</title>
    
    <!-- Google Fonts for Premium Typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;700&family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Vis.js for Network Graph -->
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <!-- N3.js for RDF Parsing -->
    <script src="https://unpkg.com/n3/browser/n3.min.js"></script>

    <style>
        :root {
            --bg-color: #0f172a;
            --text-color: #f8fafc;
            --card-bg: rgba(30, 41, 59, 0.7);
            --card-border: rgba(148, 163, 184, 0.1);
            --accent-primary: #38bdf8;
            --accent-secondary: #818cf8;
            --glass-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --chat-bg-bot: rgba(56, 189, 248, 0.15);
            --chat-bg-user: rgba(129, 140, 248, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Outfit', 'Noto Sans KR', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden; /* Full screen map */
            height: 100vh;
            width: 100vw;
        }

        /* UI Overlay Elements */
        .ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            max-width: 350px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            height: calc(100vh - 40px);
        }

        .card {
            background: var(--card-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--card-border);
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: var(--glass-shadow);
            pointer-events: auto;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .info-card {
            flex-shrink: 0;
        }
        
        /* Chat Interface */
        .chat-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            min-height: 0; /* Important for flex scrolling */
            padding: 0; /* Override default card padding */
            overflow: hidden;
        }

        .chat-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--card-border);
            background: rgba(15, 23, 42, 0.3);
        }

        .chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .message {
            max-width: 85%;
            padding: 0.8rem 1rem;
            border-radius: 12px;
            font-size: 0.9rem;
            line-height: 1.4;
            word-wrap: break-word;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

        .message.bot {
            background-color: var(--chat-bg-bot);
            align-self: flex-start;
            border-bottom-left-radius: 2px;
            border: 1px solid rgba(56, 189, 248, 0.2);
        }

        .message.user {
            background-color: var(--chat-bg-user);
            align-self: flex-end;
            border-bottom-right-radius: 2px;
            border: 1px solid rgba(129, 140, 248, 0.2);
        }

        .chat-input-area {
            padding: 1rem;
            border-top: 1px solid var(--card-border);
            display: flex;
            gap: 0.5rem;
            background: rgba(15, 23, 42, 0.3);
        }

        .chat-input-area input {
            flex-grow: 1;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 0.6rem 1rem;
            color: white;
            font-family: inherit;
            outline: none;
            transition: border-color 0.2s;
        }

        .chat-input-area input:focus {
            border-color: var(--accent-primary);
        }

        .chat-input-area button {
            background: var(--accent-primary);
            color: #0f172a;
            border: none;
            border-radius: 8px;
            padding: 0 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .chat-input-area button:hover {
            background: var(--accent-secondary);
        }

        /* Typography */
        h1 {
            font-size: 1.6rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }
        
        h3 {
            font-size: 1.1rem;
            color: var(--accent-primary);
            margin: 0;
        }

        p {
            font-size: 0.9rem;
            color: #cbd5e1;
            margin-bottom: 1rem;
        }

        /* Legend */
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.3rem;
            font-size: 0.85rem;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        /* Graph Container */
        #mynetwork {
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #1e293b 0%, #0f172a 100%);
        }

        /* Status bar */
        .status-bar {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 0.8rem;
            color: #64748b;
            background: rgba(15, 23, 42, 0.8);
            padding: 5px 10px;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.05);
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div class="ui-container">
        <!-- Info Card -->
        <div class="card info-card">
            <h1>í† ë¼ì™€ ê±°ë¶ì´</h1>
            <p>ê·¸ë˜í”„ë¥¼ í´ë¦­í•˜ê±°ë‚˜ ì•„ë˜ ì±„íŒ…ì°½ì—ì„œ ì§ˆë¬¸í•´ë³´ì„¸ìš”!</p>
            
            <div style="margin-top: 10px;">
                <div class="legend-item"><div class="dot" style="background: #fbbf24;"></div>Story (ì´ì•¼ê¸°)</div>
                <div class="legend-item"><div class="dot" style="background: #60a5fa;"></div>Character (ë“±ì¥ì¸ë¬¼)</div>
                <div class="legend-item"><div class="dot" style="background: #f87171;"></div>Event (ì‚¬ê±´)</div>
                <div class="legend-item"><div class="dot" style="background: #34d399;"></div>Moral (êµí›ˆ)</div>
            </div>
        </div>

        <!-- Chat Interface -->
        <div class="card chat-container">
            <div class="chat-header">
                <h3>ğŸ° ì´ì•¼ê¸° ë´‡ì—ê²Œ ë¬¼ì–´ë´! ğŸ¢</h3>
            </div>
            <div class="chat-messages" id="chat-messages">
                <div class="message bot">
                    ì•ˆë…•! ë‚˜ëŠ” ì´ì•¼ê¸° ë´‡ì´ì•¼. <br>
                    "ëˆ„ê°€ ê²½ì£¼ì—ì„œ ì´ê²¼ì–´?" <br>
                    "ê±°ë¶ì´ê°€ ì´ê¸´ ì´ìœ ëŠ” ë­ì•¼?" <br>
                    "êµí›ˆì´ ë­ì•¼?" <br>
                    ê°™ì´ ê¶ê¸ˆí•œ ê±¸ ë¬¼ì–´ë´ ì¤˜!
                </div>
            </div>
            <div class="chat-input-area">
                <input type="text" id="user-input" placeholder="ì§ˆë¬¸ì„ ì…ë ¥í•˜ì„¸ìš”..." onkeypress="handleKeyPress(event)">
                <button onclick="sendMessage()">ì „ì†¡</button>
            </div>
        </div>
    </div>

    <div id="mynetwork"></div>
    <div class="status-bar">Powered by Vis.js & N3.js</div>

    <script>
        // Fallback data
        const embeddedTTL = `
@prefix ex: <http://example.org/fable/> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

# ì´ì•¼ê¸°
ex:TortoiseAndHare
    rdf:type ex:Story ;
    rdfs:label "í† ë¼ì™€ ê±°ë¶ì´"@ko ;
    ex:hasCharacter ex:Hare , ex:Tortoise ;
    ex:hasEvent ex:Race ;
    ex:hasMoral ex:Perseverance .

# ë“±ì¥ì¸ë¬¼
ex:Hare
    rdf:type ex:Character ;
    rdfs:label "í† ë¼"@ko ;
    ex:hasTrait "ë¹ ë¥´ì§€ë§Œ ìë§Œí•¨"@ko .

ex:Tortoise
    rdf:type ex:Character ;
    rdfs:label "ê±°ë¶ì´"@ko ;
    ex:hasTrait "ëŠë¦¬ì§€ë§Œ ì„±ì‹¤í•¨"@ko .

# ì‚¬ê±´
ex:Race
    rdf:type ex:Event ;
    rdfs:label "ë‹¬ë¦¬ê¸° ê²½ì£¼"@ko ;
    ex:participant ex:Hare , ex:Tortoise ;
    ex:winner ex:Tortoise .

# êµí›ˆ
ex:Perseverance
    rdf:type ex:Moral ;
    rdfs:label "ê¾¸ì¤€í•¨ì´ ìë§Œì„ ì´ê¸´ë‹¤"@ko .
`;

        // Global objects
        let network;
        let nodes;
        let edges;
        let store = new N3.Store();
        const { DataFactory } = N3;
        const { namedNode, literal, defaultGraph, quad } = DataFactory;
        
        // Namespaces
        const EX = 'http://example.org/fable/';
        const RDFS = 'http://www.w3.org/2000/01/rdf-schema#';

        async function loadData() {
            try {
                const response = await fetch('story.ttl');
                if (!response.ok) throw new Error('Network response was not ok');
                return await response.text();
            } catch (error) {
                console.warn("Fetch failed, using embedded fallback.", error);
                return embeddedTTL;
            }
        }

        async function init() {
            const ttlData = await loadData();
            const parser = new N3.Parser();
            
            parser.parse(ttlData, (error, quad, prefixes) => {
                if (error) {
                    console.error("Parsing error:", error);
                    return;
                }
                if (quad) {
                    store.addQuad(quad); // Add to N3 Store
                } else {
                    visualize();
                }
            });
        }

        function getNodeColor(uri) {
            // Find type of this node from store
            const typeQuads = store.getQuads(namedNode(uri), namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'), null, null);
            let type = "";
            if (typeQuads.length > 0) {
                type = typeQuads[0].object.value.toLowerCase();
            }

            if (type.includes('story')) return '#fbbf24'; // amber
            if (type.includes('character')) return '#60a5fa'; // blue
            if (type.includes('event')) return '#f87171'; // red
            if (type.includes('moral')) return '#34d399'; // emerald
            return '#94a3b8'; // default
        }

        function getLabel(term) {
            if (term.termType === 'Literal') return term.value;
            if (term.termType === 'NamedNode') {
                // Try to find rdfs:label
                const labels = store.getQuads(term, namedNode(RDFS + 'label'), null, null);
                if (labels.length > 0) return labels[0].object.value;
                
                // Fallback to URI fragment
                const parts = term.value.split(/[\/#]/);
                return parts[parts.length - 1];
            }
            return term.value;
        }

        function visualize() {
            nodes = new vis.DataSet();
            edges = new vis.DataSet();
            const addedNodes = new Set();

            store.forEach(quad => {
                const subj = quad.subject;
                const pred = quad.predicate;
                const obj = quad.object;

                if (!addedNodes.has(subj.value)) {
                    nodes.add({
                        id: subj.value,
                        label: getLabel(subj),
                        color: { background: getNodeColor(subj.value), border: '#fff' },
                        shape: 'dot',
                        size: 20,
                        font: { color: '#f8fafc', face: 'Outfit' }
                    });
                    addedNodes.add(subj.value);
                }

                if (!addedNodes.has(obj.value)) {
                    let color = '#94a3b8';
                    let shape = 'dot';
                    let fontColor = '#f8fafc';

                    if (obj.termType === 'Literal') {
                        color = '#a78bfa'; // purple
                        shape = 'box';
                    } else if (pred.value === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type') {
                        color = '#e2e8f0';
                        shape = 'diamond';
                        fontColor = '#0f172a';
                    } else {
                        color = getNodeColor(obj.value);
                    }

                    nodes.add({
                        id: obj.value,
                        label: getLabel(obj),
                        color: { background: color, border: '#fff' },
                        shape: shape,
                        size: obj.termType === 'Literal' ? 15 : 20,
                        font: { color: fontColor, face: 'Outfit' }
                    });
                    addedNodes.add(obj.value);
                }

                edges.add({
                    from: subj.value,
                    to: obj.value,
                    label: getLabel(pred),
                    arrows: 'to',
                    color: { color: 'rgba(148, 163, 184, 0.4)' },
                    font: { color: '#94a3b8', size: 10, align: 'middle' }
                });
            });

            // Focus on winning node if asked? No, just render.
            const container = document.getElementById('mynetwork');
            const data = { nodes: nodes, edges: edges };
            const options = {
                nodes: { borderWidth: 2, shadow: true },
                physics: { stabilization: false },
                interaction: { hover: true }
            };

            network = new vis.Network(container, data, options);
            
            // Click to chat hack
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                     const nodeId = params.nodes[0];
                     const label = nodes.get(nodeId).label;
                     document.getElementById('user-input').value = label + "ì— ëŒ€í•´ ì•Œë ¤ì¤˜";
                }
            });
        }

        /* ----------------------------------------------------
           Chatbot Logic
           ---------------------------------------------------- */
        function handleKeyPress(e) {
            if (e.key === 'Enter') sendMessage();
        }

        function appendMessage(text, sender) {
            const chatBox = document.getElementById('chat-messages');
            const div = document.createElement('div');
            div.className = `message ${sender}`;
            div.innerHTML = text; // allow html
            chatBox.appendChild(div);
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        function sendMessage() {
            const input = document.getElementById('user-input');
            const question = input.value.trim();
            if (!question) return;

            appendMessage(question, 'user');
            input.value = '';

            // Simulate thinking delay
            setTimeout(() => {
                const answer = generateAnswer(question);
                appendMessage(answer, 'bot');
            }, 500);
        }

        function generateAnswer(q) {
            // Simple keyword-based intent matching on the N3 store
            
            // 1. Who won? (ëˆ„ê°€ ì´ê²¼ì–´, ìŠ¹ì, ìš°ìŠ¹)
            if (q.match(/ëˆ„ê°€|ìŠ¹ì|ìš°ìŠ¹|ìŠ¹ë¦¬|1ë“±|ì´ê²¼/)) {
                // Find event with ex:winner
                const winners = [];
                // Query: ?event ex:winner ?winner
                const raceEvents = store.getQuads(null, namedNode(EX + 'winner'), null, null);
                
                if (raceEvents.length > 0) {
                    const winnerNode = raceEvents[0].object;
                    const winnerName = getLabel(winnerNode); // "ê±°ë¶ì´"
                    
                    // Highlight node
                    network.selectNodes([winnerNode.value]);
                    network.focus(winnerNode.value, { scale: 1.2, animation: true });

                    return `ê²½ì£¼ì˜ ìŠ¹ìëŠ” <strong>${winnerName}</strong>ì•¼!`;
                }
                return "ìŒ.. ëˆ„ê°€ ì´ê²¼ëŠ”ì§€ ë°ì´í„°ì—ì„œ ì°¾ì„ ìˆ˜ê°€ ì—†ì–´.";
            }

            // 2. Why did they win? (ì™œ ì´ê²¼ì–´, ì´ìœ )
            if (q.match(/ì™œ|ì´ìœ |ë¹„ê²°|ì–´ë–»ê²Œ/)) {
                // Determine context. Do they mean Tortoise?
                // Logic: Find winner, find winner's trait, find moral.
                const raceEvents = store.getQuads(null, namedNode(EX + 'winner'), null, null);
                if (raceEvents.length > 0) {
                     const winnerNode = raceEvents[0].object;
                     const winnerName = getLabel(winnerNode);
                     
                     // Find trait
                     const traits = store.getQuads(winnerNode, namedNode(EX + 'hasTrait'), null, null);
                     let traitText = "";
                     if (traits.length > 0) traitText = traits[0].object.value; // "ëŠë¦¬ì§€ë§Œ ì„±ì‹¤í•¨"
                     
                     // Find moral
                     const morals = store.getQuads(null, namedNode(EX + 'hasMoral'), null, null);
                     let moralText = "";
                     if (morals.length > 0) {
                        const moralNode = morals[0].object;
                        const moralLabels = store.getQuads(moralNode, namedNode(RDFS + 'label'), null, null);
                        if (moralLabels.length > 0) moralText = moralLabels[0].object.value; // "ê¾¸ì¤€í•¨ì´ ìë§Œì„ ì´ê¸´ë‹¤"
                     }

                     return `${winnerName}ê°€ ì´ê¸´ ì´ìœ ëŠ” <strong>"${traitText}"</strong>ì´ê¸° ë•Œë¬¸ì´ì•¼.<br>
                             ì´ ì´ì•¼ê¸°ì˜ êµí›ˆì€ <strong>"${moralText}"</strong>ë€ë‹¤.`;
                }
                return "ê¸€ì„.. ì •í™•í•œ ì´ìœ ëŠ” ì´ì•¼ê¸° ë°ì´í„°ì— ì—†ì§€ë§Œ, ê¾¸ì¤€í•¨ ë•Œë¬¸ì´ ì•„ë‹ê¹Œ?";
            }

            // 3. Moral (êµí›ˆ)
            if (q.match(/êµí›ˆ|ë°°ìš¸|ì£¼ì œ/)) {
                // Find Moral
                const morals = store.getQuads(null, namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'), namedNode(EX + 'Moral'), null);
                if (morals.length > 0) {
                    const moralNode = morals[0].subject;
                    const label = getLabel(moralNode);
                    
                    network.selectNodes([moralNode.value]);
                    network.focus(moralNode.value, { scale: 1.2, animation: true });

                    return `ì´ ì´ì•¼ê¸°ì˜ êµí›ˆì€ <strong>"${label}"</strong>ì•¼.`;
                }
                return "êµí›ˆì„ ì°¾ì„ ìˆ˜ ì—†ì–´.";
            }

            // 4. Character info (í† ë¼, ê±°ë¶ì´)
            if (q.match(/í† ë¼/)) {
                return getCharacterInfo(EX + 'Hare', "í† ë¼");
            }
            if (q.match(/ê±°ë¶/)) {
                return getCharacterInfo(EX + 'Tortoise', "ê±°ë¶ì´");
            }

            return "ë¯¸ì•ˆí•´, ì˜ ì´í•´í•˜ì§€ ëª»í–ˆì–´. 'ëˆ„ê°€ ì´ê²¼ì–´?' ë˜ëŠ” 'êµí›ˆì´ ë­ì•¼?' ë¼ê³  ë¬¼ì–´ë´ ì¤˜!";
        }

        function getCharacterInfo(uri, name) {
            const charNode = namedNode(uri);
            const traits = store.getQuads(charNode, namedNode(EX + 'hasTrait'), null, null);
            
            if (traits.length > 0) {
                const trait = traits[0].object.value;
                network.selectNodes([uri]);
                network.focus(uri, { scale: 1.2, animation: true });
                return `${name}ì˜ íŠ¹ì§•ì€ <strong>"${trait}"</strong>ì´ì•¼.`;
            }
            return `${name}ì— ëŒ€í•œ ì •ë³´ê°€ ë¶€ì¡±í•´.`;
        }

        init();
        
        // Handle window resize
        window.addEventListener('resize', () => {
             // UI rendering updates if needed
        });

    </script>
</body>
</html>
